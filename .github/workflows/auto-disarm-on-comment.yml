name: Disarm auto-close on reply

on:
  issue_comment:
    types: [created]

jobs:
  disarm-on-comment:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    env:
      TRIGGER_LABEL: "Awaiting response"
      GRACE_DAYS: "2"
      BUFFER_MINUTES: "120"
      ALLOWED_STARTERS: "qlerup"
    steps:
      - name: Disarm if reporter replies
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const issue = context.payload.issue;
            const newComment = context.payload.comment;

            // Issues only, not PRs
            if (issue.pull_request) {
              core.info(`PR #${issue.number} – skipping`);
              return;
            }

            // Skip bots
            if ((newComment.user?.type === 'Bot')) {
              core.info('Bot comment – skipping');
              return;
            }

            const sender = (newComment.user?.login || "").toLowerCase();

            // Only if trigger label is actually on the issue
            const trigger = (process.env.TRIGGER_LABEL || "").toLowerCase();
            const hasTriggerLabel = (issue.labels || [])
              .some(l => (l.name || "").toLowerCase() === trigger);

            if (!hasTriggerLabel) {
              core.info(`#${issue.number}: has no trigger label – skipping`);
              return;
            }

            // Maintainer(s) who are allowed to "arm" – they should NOT auto-disarm
            const allowed = new Set((process.env.ALLOWED_STARTERS || "")
              .split(",").map(s => s.trim().toLowerCase()).filter(Boolean));

            const isMaintainer =
              (allowed.size === 0 && sender === owner.toLowerCase()) ||
              allowed.has(sender);

            if (isMaintainer) {
              core.info(`#${issue.number}: comment by maintainer @${sender} – not disarming`);
              return;
            }

            // Fetch all comments to find the latest marker
            const comments = await github.paginate(
              github.rest.issues.listComments,
              { owner, repo, issue_number: issue.number, per_page: 100 }
            );

            const marker = [...comments].reverse().find(c =>
              (c.user?.type === 'Bot') &&
              (c.user?.login || '').includes('github-actions') &&
              /<!--\s*autoclose:start:/.test(c.body || '')
            );

            if (!marker) {
              core.info(`#${issue.number}: no marker comment – skipping`);
              return;
            }

            // Only disarm if THIS comment is newer than the marker
            const markerTime = new Date(marker.created_at);
            const thisCommentTime = new Date(newComment.created_at);

            if (thisCommentTime <= markerTime) {
              core.info(`#${issue.number}: comment is older than marker – skipping`);
              return;
            }

            // All good ⇒ remove label and post message
            try {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number: issue.number,
                name: process.env.TRIGGER_LABEL
              });
            } catch (e) {
              core.info(`#${issue.number}: could not remove label (${e.message}) – continuing`);
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issue.number,
              body: `Thanks for your reply! Auto-close has now been **disarmed** (label **${process.env.TRIGGER_LABEL}** has been removed).`
            });

            core.info(`#${issue.number}: reply from non-maintainer – auto-close disarmed`);