name: Auto-close labeled issues (hourly + buffer)

on:
  schedule:
    - cron: '0 * * * *'   # hourly (UTC)
  workflow_dispatch:

jobs:
  sweep:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    env:
      TRIGGER_LABEL: "Awaiting response"  # your label
      CLOSED_LABEL: "closed-by-automation"
      GRACE_DAYS: "2"
      BUFFER_MINUTES: "120"
      ALLOWED_STARTERS: "qlerup"
    steps:
      - name: Sweep and close if no reply since arming
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            const graceMs = parseInt(process.env.GRACE_DAYS || "2", 10) * 24 * 60 * 60 * 1000;
            const bufferMs = parseInt(process.env.BUFFER_MINUTES || "0", 10) * 60 * 1000;
            const allowed = new Set((process.env.ALLOWED_STARTERS || "")
              .split(",").map(s => s.trim().toLowerCase()).filter(Boolean));

            async function ensureLabel(name, color, description) {
              try { await github.rest.issues.getLabel({ owner, repo, name }); }
              catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, name, color, description });
                } else { throw e; }
              }
            }
            await ensureLabel(process.env.CLOSED_LABEL, 'ededed', 'Closed automatically by workflow');

            // Open issues with the trigger label (exact name)
            const issues = await github.paginate(
              github.rest.issues.listForRepo,
              { owner, repo, state: 'open', labels: process.env.TRIGGER_LABEL, per_page: 100 }
            );

            const now = new Date();

            for (const issue of issues) {
              if (issue.pull_request) { core.info(`#${issue.number}: PR – skipping`); continue; }

              // Fetch comments
              const comments = await github.paginate(
                github.rest.issues.listComments,
                { owner, repo, issue_number: issue.number, per_page: 100 }
              );

              // Find the latest marker from the GitHub Actions bot
              const marker = [...comments].reverse().find(c =>
                (c.user?.type === 'Bot') &&
                (c.user?.login || '').includes('github-actions') &&
                /<!--\s*autoclose:start:/.test(c.body || '')
              );
              if (!marker) { core.info(`#${issue.number}: no marker – skipping`); continue; }

              const m = (marker.body || '').match(/autoclose:start:([0-9T:\-:.Z]+)/);
              if (!m) { core.info(`#${issue.number}: marker without timestamp – skipping`); continue; }

              const start = new Date(m[1]);
              const elapsed = now - start;

              // Respect grace + buffer
              if (elapsed < (graceMs + bufferMs)) {
                core.info(`#${issue.number}: within grace+buffer – skipping`);
                continue;
              }

              // Any reply after the marker (not a bot, not a maintainer)?
              const hasReply = comments.some(c => {
                const after = new Date(c.created_at) > start;
                const byBot = (c.user?.type === 'Bot');
                const byMaintainer = allowed.has((c.user?.login || '').toLowerCase());
                return after && !byBot && !byMaintainer;
              });

              if (hasReply) {
                // Disarm: remove label and notify
                try {
                  await github.rest.issues.removeLabel({
                    owner, repo, issue_number: issue.number, name: process.env.TRIGGER_LABEL
                  });
                } catch (e) { /* ignore */ }
                await github.rest.issues.createComment({
                  owner, repo, issue_number: issue.number,
                  body: `Thanks for the reply! Auto-close disarmed (label **${process.env.TRIGGER_LABEL}** removed).`
                });
                core.info(`#${issue.number}: reply detected – label removed`);
                continue;
              }

              // No reply ⇒ close
              await github.rest.issues.update({ owner, repo, issue_number: issue.number, state: 'closed' });
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name: process.env.TRIGGER_LABEL });
              } catch (e) { /* ignore */ }
              await github.rest.issues.addLabels({ owner, repo, issue_number: issue.number, labels: [process.env.CLOSED_LABEL] });

              await github.rest.issues.createComment({
                owner, repo, issue_number: issue.number,
                body: `No reply after **${process.env.GRACE_DAYS} day(s)** (+${process.env.BUFFER_MINUTES} min buffer) since label **${process.env.TRIGGER_LABEL}** was applied. Auto-closing.\n\nComment to reopen if needed.`
              });

              core.info(`Closed #${issue.number} due to inactivity.`);
            }